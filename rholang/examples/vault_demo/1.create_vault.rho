// A tesetnet admin will create vaults for you if you don't have a friend on-chain already

new
  rl(`rho:registry:lookup`), revAddress(`rho:rev:address`), RevVaultCh,
  vaultLockedCh, revAddressCh, vaultLockedCh,
  stdout(`rho:io:stdout`), log
in {

  rl!(`rho:id:1o93uitkrjfubh43jt19owanuezhntag5wh74c6ur5feuotpi73q8z`, *RevVaultCh) |
  for (@(_, RevVault) <- RevVaultCh) {

    log!(("1.create_vault.rho")) |

    // CHANGE THE PUBLIC KEY HERE vvv
    match "%PUB_KEY" {
      publicKey => {

        log!(("Creating vault for publicKey", publicKey)) |
  
        @RevVault!("findOrCreate", publicKey.hexToBytes(), *vaultLockedCh) |
        revAddress!("fromPublicKey", publicKey.hexToBytes(), *revAddressCh) |
    
        for (@("Right", vaultLocked) <- vaultLockedCh; @revAddress <- revAddressCh) {
          log!(("Vault for publicKey / RevAddress", publicKey, "/", revAddress, "created, trying to use it")) |
    
          new balanceCh in {
            @vaultLocked!("balance", *balanceCh) |
            for (balance <- balanceCh) {
              log!(("THIS CANNOT BE! The returned `Lockbox` only responds to the `unlock` method"))
            }
          } |
    
          new vaultUnlockedCh in {
            log!(("Unlocking the vault:")) |
            @vaultLocked!("unlock", *vaultUnlockedCh) |
            for (@result <- vaultUnlockedCh) {
              match result {
                Nil => {
                  log!(("Unlocking failed, which is good. The 3rd party creating the vault has no access to it"))
                }
                vault => {
                  log!((
                    "Congratulations! You've created your own vault yourself.",
                    "This may or may not be possible in the future depending on how we handle charging for execution :)"
                  ))
                }
              }
            }
          }
        }
  
      }
    }

  } |

  contract log(@data) = {
    @"DEMO"!(data) | stdout!(data)
  }
}

