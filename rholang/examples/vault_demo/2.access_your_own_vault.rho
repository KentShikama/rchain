new
  revAddress(`rho:rev:address`), rl(`rho:registry:lookup`), RevVaultCh, getDeployData(`rho:deploy:params`),
  getDeployerPubKey, deployerPubKeyCh, vaultLockedCh, vaultUnlockedCh, balanceCh,
  stdout(`rho:io:stdout`), log
in {

  // we'll consider making RevVault a system contract under `rho:rev:vault`
  rl!(`rho:id:1o93uitkrjfubh43jt19owanuezhntag5wh74c6ur5feuotpi73q8z`, *RevVaultCh) |
  for (@(_, RevVault) <- RevVaultCh) {

    log!(("2.access_your_own_vault.rho")) |

    getDeployerPubKey!(*deployerPubKeyCh) |
    for (@pubKey <- deployerPubKeyCh) {

      log!(("Using public key:", pubKey, "to obtain a `deployer's-pubkey-bound` vault")) |

      // most RevVault methods return an `Either[String, A] = ("Left", String) \/ ("Right", A)`
      // the Either type is going to be restated as `Either[String, A] = (false, String) \/ (true, A)`
      @RevVault!("findOrCreate", pubKey, *vaultLockedCh) |
      for (@("Right", vaultLocked) <- vaultLockedCh) {

        log!("Unlocking vault") |

        @vaultLocked!("unlock", *vaultUnlockedCh) |
        for (@res <- vaultUnlockedCh) {

          match (res) {
            Nil => {
              log!("Unlocking failed")
            }
            vault => {
              log!("Unlocking succeeded") |

              @vault!("balance", *balanceCh) |
              for (@balance <- balanceCh) {

                log!(("Balance is", balance))
              }
            }
          }
        }
      }
    }

  } |

  contract getDeployerPubKey(retCh) = {
    new ch in {
      getDeployData!(*ch) |
      for (_, _, @pubKey, _ <- ch) {
        log!(("Deployer public key is:", pubKey)) |
        retCh!(pubKey)
      }
    }
  } |

  contract log(@data) = {
    @"DEMO"!(data) | stdout!(data)
  }
}

