;;; File containing the reflective method produce and its helper methods

(defOprn fetch_pattern_and_product)
(defProc (fetch_pattern_and_product chart channel product_patterns channel_index channel_position) 
    (if (= channel_index channel_position)
        [channel -1]
        (let [[[data_list continuation_struct_list] (tbl-get chart channel)]]
			(if (null? data_list)
				[]
				(iterate loop [[[data & r] data_list] [data_index 0]]
					(if (match_pattern (tuple-safe-nth product_patterns channel_index) data)
						[channel data_index]
						(loop r (inc data_index))
					)
				)
			)
        )
    )
)


;;; Roughly dual to extract_data_candidates.
;;; However, it is more complicated as it has to gather candidates across multiple channels.
;;;
;;; Roughly equivalent to the following python-ish pseudocode.
;;;
;;; def extract_consume_candidates(concat_channels, chart, channel, product, reverse_channel_lookup_table):
;;;     NOT_STORED = -1 # Constant to signify that the current product should be used as part of the reduction
;;;     candidates = 
;;;         map_with_index _, concat_channel in concat_channels:
;;;             channels = reverse_lookup(concat_channel)
;;;             channel_position = channels.index_of(channel)
;;;             data_list, continuation_struct_list = chart.get(concat_channel)
;;;             map_with_index continuation_struct_index, continuation_struct in continuation_struct_list:
;;;                 product_patterns, ctxt_stuff = continuation_struct
;;;                 if match_pattern(product_patterns[channel_position], product):
;;;                     def fetch_pattern_and_product(channel_index, channel):
;;;                         if channel_index == channel_position:
;;;                             [channel NOT_STORED]
;;;                         else:
;;;                             data_list, continuation_struct_list = chart.get(channel)
;;;                             for data_index, data in enumerate(data_list):
;;;                                 # Note here we are taking the first available match but this could also be a ranked choice
;;;                                 if match?(product_patterns[channel_index], data):
;;;                                     [channel data_index]
;;;                     candidate = map_with_index(fetch_pattern_and_product, channels)
;;;                     [] if any_null?(candidate) else (candidate, [concat_channel continuation_struct_index])
;;;     return flatten(candidates)
;;;
;;; While RBL is untyped, the following is some of the would be inferred types
;;;
;;;     type Candidate = Tuple2[List[Tuple2[String, Int]], Tuple2[String, Int]]
;;;     type Candidates = List[Candidate]
(defOprn extract_consume_candidates)
(defProc (extract_consume_candidates concat_channels chart channel product reverse_channel_lookup_table)
    (if (absent? concat_channels)
        []
        (let [[candidates
                (map concat_channels (proc [_ concat_channel]
                    (let*
                        [
                            [channels (tbl-get reverse_channel_lookup_table concat_channel)]
                            [channel_position (position channels channel)]
                            [[data_list continuation_struct_list] (tbl-get chart concat_channel)]
                        ]
                        (map continuation_struct_list (proc [continuation_struct_index continuation_struct]
                            (let*
                                [[[product_patterns ctxt_stuff] continuation_struct]]
                                (if (match_pattern (tuple-safe-nth product_patterns channel_position) product)
                                    (let
                                        [[candidate (map channels (proc [i channel]
                                            (fetch_pattern_and_product chart channel product_patterns i channel_position)))]]
                                        (if (any_null? candidate)
                                            []
                                            [candidate [concat_channel continuation_struct_index]]
                                        )))))))))]]
            (flatten candidates)
        )
    )
)

;;; Dual to select_best_products in consume.rbl
(defOprn select_best_consume)
(defProc (select_best_consume candidates)
    (head (filter candidates (proc [candidate]
        (if (null? candidate)
            #f
            (not (any_null? (tuple-safe-nth candidate 0)))))))
)

(defOprn delete_product)
(defProc (delete_product chart channel data_index product)
    (if (= data_index -1)
        product
        (let*
            [
                [[data_list continuation_struct_list] (tbl-get chart channel)]
                [data (tuple-safe-nth data_list data_index)]
                [updated_data_list (delete-i data_list data_index)]
            ]
            (seq
                (tbl-add chart channel [updated_data_list continuation_struct_list])
                data
            )
        )
    )
)

;;; Dual to consume_products.
;;; This method deletes channels from channel_lookup_table and reverse_channel_lookup_table
;;; if the corresponding channel continuation_struct_list's are empty.
(defOprn consume_continuation)
(defProc (consume_continuation candidate chart channel_lookup_table reverse_channel_lookup_table product)
    (let*
        [
            [[channel_data_list [concat_channel continuation_struct_index]] candidate]
            [product_list (map channel_data_list (proc [i [channel data_index]] (delete_product chart channel data_index product)))]
            [[data_list continuation_struct_list] (tbl-get chart concat_channel)]
            [[product_patterns ctxt_tuple] (tuple-safe-nth continuation_struct_list continuation_struct_index)]
            [updated_continuation_struct_list (delete-i continuation_struct_list continuation_struct_index)]
            [_ (tbl-add chart concat_channel [data_list updated_continuation_struct_list])]
        ]
        (seq
            (if (null? updated_continuation_struct_list)
                (let*
                    [
                        [channels_to_delete (tbl-get reverse_channel_lookup_table concat_channel)]
                    ]
                    (seq
                        (map channels_to_delete (proc [i channel]
                            (let*
                                [
                                    [channels (tbl-get channel_lookup_table channel)]
                                    [updated_channels (delete channels concat_channel)]
                                ]
                                (tbl-add channel_lookup_table channel updated_channels)
                            )
                        ))
                        (tbl-del reverse_channel_lookup_table concat_channel)
                    )
                )
            )
            [ctxt_tuple product_patterns product_list]
        )
    )
)

;;; The produce method is roughly dual to the consume method in consume.rbl.
;;; While consume can suspend the thread of execution, 
;;; produce always resumes the calling thread at the end of the method.
(defOprn produce)
(defRMethod NameSpace (produce ctxt-tuple & production)
(let*
    [
        [[ctxt _] ctxt-tuple]
        [[channel product] production]
        [_ (display "INFO:  (produce) " (clean_fresh channel) "!(" product ") called" #\\n)]
        [concat_channels (tbl-get channel_lookup_table channel)]
	    [_ (display "DEBUG: (produce)" #\\t "relevant channels: " concat_channels #\\n)]
        [candidates (extract_consume_candidates concat_channels chart channel product reverse_channel_lookup_table)]
        [_ (display "DEBUG: (produce)" #\\t "candidates: " candidates #\\n)]
        [candidate (select_best_consume candidates)]
        [_ (display "DEBUG: (produce)" #\\t "candidate: " candidate #\\n)]
    ]
    (if (null? candidate)
        (let [[subspace (tbl-get chart channel)]]
            (seq
                (display "DEBUG: (produce)" #\\t "storing(" product ")" #\\n)
                (if (= #absent subspace)
                    (tbl-add chart channel [[product] []])
                    (let [[[data_list continuation_struct_list] subspace]]
                        (tbl-add chart channel [(append data_list product) continuation_struct_list]))
                )
                (ctxt-rtn ctxt [])
                (update!)
            )
        )
        (let*
            [
                [[ctxt_tuple product_patterns product_list] (consume_continuation candidate chart channel_lookup_table reverse_channel_lookup_table product)]
                [[consume_ctxt [code env] persistent] ctxt_tuple]
            ]
            (seq
                (display "DEBUG: (produce)" #\\t "ctxt-rtn(" consume_ctxt ", " product_list ")" #\\n)
                (ctxt-rtn consume_ctxt product_list)
                (ctxt-rtn ctxt [])
                (update!)
                (if persistent
                    (seq
                        (display "DEBUG: (produce) Re-posting continuation: " code #\\n)
                        (run-with-env code env)
                    )
                )
            )
        )
    )
))
