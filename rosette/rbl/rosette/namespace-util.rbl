;;; TODO: Remove unused methods in Tuplespace and add tests for the rest

;;; TODO: Add tag for whether persistent
;;; TODO: Translate match in compiler

(random-number-init)
;;; The debugSymbol is inserted so that the output is easier to read
(defOprn generateFresh)
(defProc (generateFresh debugSymbol)
  (->symbol
   (string-concat "Rholang-" debugSymbol "-" (->string (random-number)))))

(defOprn append)
(defPure Tuple (append item)
  (concat (self) [item]))

;;; Deletes element at position i in Tuple
(defOprn delete-i)
(defPure Tuple (delete-i p)
  (concat (prim-sub-object (self) 0 p)
          (prim-sub-object (self) (fx+ p 1)
                           (fx- (prim-size (self)) (fx+ p 1)))))

(defOprn symbol-list-concat)
(defPure Tuple (symbol-list-concat) (->symbol (fold (self)
                                                    (proc [e acc k]
                                                      (k (string-concat acc (->string e)))) "")))

;;; TODO: Figure out a more general flatten method
(defOprn append-tuples)
(defPure Nil (append-tuples) [])
(defPure Tuple (append-tuples) (concat & (self)))

;;; TODO: Eliminate with implemenation of https://rchain.atlassian.net/browse/ROS-340
(defOprn tbl-unique-append)
(defPure RblTable (tbl-unique-append key value)
  (let [[current-value (tbl-get (self) key)]]
    (if (or (absent? current-value) (null? current-value))
        (tbl-add (self) key [value])
        (if (type? current-value Tuple)
            (tbl-add (self) key (remove-duplicates (concat [value] current-value)))
            (RuntimeError (self) "Value " current-value " at key " key " not a Tuple")))))

(defOprn tuplespace-tbl-get-or-create)
(defPure RblTable (tuplespace-tbl-get-or-create channel)
  (let [[subspace (tbl-get (self) channel)]]
    (if (absent? subspace)
      (seq
        (tbl-add (self) channel [[] []])
        (tbl-get (self) channel))
      subspace)))

(defOprn match-pattern)
(defOprn match-tuple-pattern)
(defProc (match-pattern ptrn product)
  (cond ((type? ptrn Symbol) #t)
        ((type? ptrn Tuple) (match-tuple-pattern ptrn product))
        (else (= ptrn product))))

(defPure Tuple (match-tuple-pattern other)
  (if (or (null? (self)) (null? other))
      (same? (self) other)
      (iterate loop [[[i & r1] (self)] [[j & r2] other]]
               (cond ((match-pattern i j)
                        (if (and (null? r1) (null? r2))
                          #t
                          (loop r1 r2)))
                     (else #f)))))


(defProc (non-niv-head list)
  (fold list (proc [item acc k] (if (niv? item) (k acc) item)) []))

(defProc (any-null? list) (any list null?))

(defProc (clean-fresh fresh)
  (let [[[rholang name & r] (string-split (->string fresh) "-")]]
    name))
